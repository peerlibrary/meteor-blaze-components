<head>
  <title>Meteor Blaze Components</title>
</head>

<body>

{{! Content should not be indented because they indent the rendered code as well. }}

<a href="https://github.com/peerlibrary/meteor-blaze-components">
  <img style="position: absolute; top: 0; right: 0; border: 0;" src="https://camo.githubusercontent.com/365986a132ccd6a44c23a9169022c0b5c890c387/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f7265645f6161303030302e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_red_aa0000.png">
</a>

<a name="meteor-blaze-components"></a>
<h1>Meteor Blaze Components</h1>

<p><a href="https://github.com/peerlibrary/meteor-blaze-components">Blaze Components</a> for <a href="https://meteor.com/">Meteor</a>
  are a system for easily developing complex UI elements that need to be reused around your Meteor app. You can use them in
  <a href="https://github.com/peerlibrary/meteor-blaze-components#javascript-and-coffeescript-support">ES2015, vanilla JavaScript, and
  CoffeeScript.</a></p>

<p>This tutorial is available in ES2015, vanilla JavaScript, and CoffeeScript. Choose your language: {{> languageChooser}}</p>

<a name="the-problem"></a>
<h2>The Problem</h2>

<p>Let's say we have an input box that auto-selects the text on click for easier changing. Its value is read from the
database and is written to it when the user changes it.</p>

<p>In plain Meteor this looks something like this:</p>

<div class="demo">
  <div class="live">
    {{> input id='demo1'}}
    {{> autoSelectDemo id='demo1'}}
  </div>

  <div class="code">
    <div class="header">spacebars</div>

{{#withSpacebars}}{{|&gt; input id='demo1'}}

&lt;template name=&quot;input&quot;&gt;
  &lt;input value="{{|value}}"/&gt;
&lt;/template&gt;{{/withSpacebars}}

{{> languageSwitch}}

{{#withCoffeeScript}}Template.input.helpers
  value: -&gt;
    # Read value from the collection.
    Values.findOne(@id)?.value

Template.input.events
  # Save value to the collection when it changes.
  'change input': (event, template) -&gt;
    Values.upsert @id, $set: value: event.target.value

  # Auto-select text when user clicks in the input.
  'click input': (event, template) -&gt;
    $(event.target).select(){{/withCoffeeScript}}

{{#withJavaScript}}Template.input.helpers({
  value: function () {
    // Read value from the collection.
    var doc = Values.findOne(this.id);
    if (doc) return doc.value;
  }
});

Template.input.events({
  // Save value to the collection when it changes.
  'change input': function (event, template) {
    Values.upsert(this.id, {$set: {
      value: event.target.value
    }});
  },

  // Auto-select text when user clicks in the input.
  'click input': function (event, template) {
    $(event.target).select();
  }
});{{/withJavaScript}}

{{#withES2015}}Template.input.helpers({
  value: function () {
    // Read value from the collection.
    var doc = Values.findOne(this.id);
    if (doc) return doc.value;
  }
});

Template.input.events({
  // Save value to the collection when it changes.
  'change input': function (event, template) {
    Values.upsert(this.id, {$set: {
      value: event.target.value
    }});
  },

  // Auto-select text when user clicks in the input.
  'click input': function (event, template) {
    $(event.target).select();
  }
});{{/withES2015}}

  </div>
</div>

<p>What if we now want the same functionality on another template?</p>

<p>Our options are:</p>
<ul>
  <li>
    <p>Duplicate the code to the other template.</p>
  </li>
  <li>
    <p>Refactor the template to {{#inlineSpacebars}}{{|> include}}{{/inlineSpacebars}} another template, or create
      a {{#inlineSpacebars}}{{|#block}}{{/inlineSpacebars}} helper that provides the functionality.</p>
  </li>
  <li>
    <p>Refactor the code instead. We save the reusable helpers and event handlers into variables and apply them on
      multiple templates.</p>
  </li>
  <li>
    <p>Create a helper class that does the same as above in an organized way and also provides inheritance, so you can
    create modified versions or extend the functionality.</p>
  </li>
</ul>
<p>What if the last option didn't require separate helper class, but it was simply how templates worked?</p>
<p>That's what Blaze Components are!</p>

<a name="the-solution"></a>
<h2>The Solution</h2>

<p>Let's make our auto-select input into a Blaze Component. You can think of a component just like you would of a
  template, except the functionality (helpers and events) are defined through a class.</p>

<div class="demo">
  <div class="live">
    {{> AutoSelectInputComponent id='demo2'}}
    {{> autoSelectDemo id='demo2'}}
  </div>

  <div class="code">
    <div class="header">spacebars</div>

{{#withSpacebars}}{{|&gt; AutoSelectInputComponent id='demo2'}}{{/withSpacebars}}

{{> languageSwitch}}

{{#withCoffeeScript}}class AutoSelectInputComponent extends BlazeComponent
  @register 'AutoSelectInputComponent'

  template: -&gt;
    'input'

  value: -&gt;
    Values.findOne(@data().id)?.value

  events: -&gt; [
    'change input': @onChange
    'click input': @onClick
  ]

  onChange: (event) -&gt;
    Values.upsert @data().id, $set: value: event.target.value

  onClick: (event) -&gt;
    $(event.target).select(){{/withCoffeeScript}}

{{#withJavaScript}}var AutoSelectInputComponent = BlazeComponent.extendComponent({
  template: function () {
    return 'input';
  },

  value: function () {
    var doc = Values.findOne(this.data().id);
    if (doc) return doc.value;
  },

  events: function () {
    return [{
      'change input': this.onChange,
      'click input': this.onClick
    }];
  },

  onChange: function (event) {
    Values.upsert(this.data().id, {$set: {
      value: event.target.value
    }});
  },

  onClick: function (event) {
    $(event.target).select();
  }
}).register('AutoSelectInputComponent');{{/withJavaScript}}

{{#withES2015}}class AutoSelectInputComponent extends BlazeComponent {
  template() {
    return 'input';
  }

  value() {
    var doc = Values.findOne(this.data().id);
    if (doc) return doc.value;
  }

  events() {
    return [{
      'change input': this.onChange,
      'click input': this.onClick
    }];
  }

  onChange(event) {
    Values.upsert(this.data().id, {$set: {
      value: event.target.value
    }});
  }

  onClick(event) {
    $(event.target).select();
  }
}

AutoSelectInputComponent.register('AutoSelectInputComponent');{{/withES2015}}

  </div>
</div>
<p>Let's look at the code part by part.</p>

{{#withCoffeeScript}}class AutoSelectInputComponent extends BlazeComponent
  @register 'AutoSelectInputComponent'{{/withCoffeeScript}}

{{#withJavaScript}}var AutoSelectInputComponent = BlazeComponent.extendComponent({
...
}).register('AutoSelectInputComponent');{{/withJavaScript}}

{{#withES2015}}class AutoSelectInputComponent extends BlazeComponent {
...
}

AutoSelectInputComponent.register('AutoSelectInputComponent');{{/withES2015}}

<p>We have created an {{#inlineCode}}AutoSelectInputComponent{{/inlineCode}}
  and registered it so we can include it just as any other template in our templates.</p>

<aside>
  <p>The convention would be to use {{#inlineCode}}AutoSelectInputComponent{{/inlineCode}}
    for the template name, to match the component's class name (and its registration name). This is also the default.</p>
  <p>We are breaking the convention in this specific case to reuse an existing template.</p>
</aside>

{{#withCoffeeScript}}template: -&gt;
  'input'{{/withCoffeeScript}}

{{#withJavaScript}}template: function () {
  return 'input';
},{{/withJavaScript}}

{{#withES2015}}template() {
  return 'input';
}{{/withES2015}}

<p>The {{#inlineCode}}input{{/inlineCode}}
  template we provided earlier will serve as the markup to be re-used by the component. It is recommended that you use
  templates only to specify DOM content, but in our case we already attached helpers and event handlers to the template
  so Blaze Components will reuse them. This is useful when you want to extend or override the behavior of an existing
  Blaze template.
  </p>

<p>For the purpose of this example we will ignore preexisting helpers and event handlers and define them again,
  but this time in a Blaze Components' way.</p>

<p>
  Helpers are simply instance methods.
</p>

<aside>
  <p>
    Notice that to get the data context, we need to call the
    <a href="https://github.com/peerlibrary/meteor-blaze-components#user-content-reference_instance_data">{{#inlineCoffeeScript}}@data(){{/inlineCoffeeScript}}{{#inlineJavaScript}}this.data(){{/inlineJavaScript}}{{#inlineES2015}}this.data(){{/inlineES2015}}</a>
    function, similar to how we call {{#inlineCoffeeScript}}@data(){{/inlineCoffeeScript}}{{#inlineJavaScript}}this.data(){{/inlineJavaScript}}{{#inlineES2015}}this.data(){{/inlineES2015}}
    in template hooks and {{#inlineCode}}template.data{{/inlineCode}} in event handlers.
  </p>
  <p>
    In normal template helpers {{#inlineCoffeeScript}}@{{/inlineCoffeeScript}}{{#inlineJavaScript}}this{{/inlineJavaScript}}{{#inlineES2015}}this{{/inlineES2015}}
    refers to the data context, but is not
    reactive. Neither is {{#inlineCoffeeScript}}@data{{/inlineCoffeeScript}}{{#inlineJavaScript}}this.data{{/inlineJavaScript}}{{#inlineES2015}}this.data{{/inlineES2015}} or
    {{#inlineCode}}template.data{{/inlineCode}}, so we had to call
    {{#inlineCode}}Template.currentData(){{/inlineCode}}
    when we wanted to register a dependency.
  </p>
  <p>
    In Blaze Components, things are consistent: {{#inlineCoffeeScript}}@{{/inlineCoffeeScript}}{{#inlineJavaScript}}this{{/inlineJavaScript}}{{#inlineES2015}}this{{/inlineES2015}}
    always refers to the component instance and
    <a href="https://github.com/peerlibrary/meteor-blaze-components#user-content-reference_instance_data">{{#inlineCoffeeScript}}@data(){{/inlineCoffeeScript}}{{#inlineJavaScript}}this.data(){{/inlineJavaScript}}{{#inlineES2015}}this.data(){{/inlineES2015}}</a>
    is always a reactive reference to the data context.
  </p>
</aside>

{{#withCoffeeScript}}value: -&gt;
  Values.findOne(@data().id)?.value{{/withCoffeeScript}}

{{#withJavaScript}}value: function () {
  var doc = Values.findOne(this.data().id);
  if (doc) return doc.value;
},{{/withJavaScript}}

{{#withES2015}}value() {
  var doc = Values.findOne(this.data().id);
  if (doc) return doc.value;
}{{/withES2015}}

<p>
  Events are returned with the <a href="https://github.com/peerlibrary/meteor-blaze-components#user-content-reference_instance_events">{{#inlineCode}}events{{/inlineCode}}</a>
  method like before, although instead of defining the handlers inline, we rather have them as instance methods, so we can override
  them from child classes later.
  <a href="https://github.com/peerlibrary/meteor-blaze-components#user-content-reference_instance_events">{{#inlineCode}}events{{/inlineCode}}</a>
  should return an array of event maps so that they can be combined in inherited classes without conflicts.
</p>

{{#withCoffeeScript}}events: -&gt; [
  'change input': @onChange
  'click input': @onClick
]

onChange: (event) -&gt;
  Values.upsert @data().id, $set: value: event.target.value

onClick: (event) -&gt;
  $(event.target).select(){{/withCoffeeScript}}

{{#withJavaScript}}events: function () {
  return [{
    'change input': this.onChange,
    'click input': this.onClick
  }];
},

onChange: function (event) {
  Values.upsert(this.data().id, {$set: {
    value: event.target.value
  }});
},

onClick: function (event) {
  $(event.target).select();
}{{/withJavaScript}}

{{#withES2015}}events() {
  return [{
    'change input': this.onChange,
    'click input': this.onClick
  }];
}

onChange(event) {
  Values.upsert(this.data().id, {$set: {
    value: event.target.value
  }});
}

onClick(event) {
  $(event.target).select();
}{{/withES2015}}

<a name="the-beauty"></a>
<h2>The Beauty</h2>

<p>Components allow us to create new components that share code simply through inheritance. Let's see
  three examples all building upon the same {{#inlineCode}}AutoSelectInputComponent{{/inlineCode}}.</p>

<a name="textarea-input"></a>
<h3>Textarea Input</h3>

<p>Let's say we want to provide the same functionality for a template using textarea form input element.</p>

<div class="demo">
  <div class="live">
    {{> AutoSelectTextareaComponent id='demo3'}}
    {{> autoSelectDemo id='demo3'}}
  </div>

  <div class="code">
    <div class="header">spacebars</div>

{{#withSpacebars}}{{|&gt; AutoSelectTextareaComponent id='demo3'}}

&lt;template name="AutoSelectTextareaComponent"&gt;
  &lt;textarea&gt;{{|value}}&lt;/textarea&gt;
&lt;/template&gt;{{/withSpacebars}}

{{> languageSwitch}}

{{#withCoffeeScript}}class AutoSelectTextareaComponent extends AutoSelectInputComponent
  @register 'AutoSelectTextareaComponent'

  template: -&gt;
    'AutoSelectTextareaComponent'

  events: -&gt;
    super.concat
      'change textarea': @onChange
      'click textarea': @onClick{{/withCoffeeScript}}

{{#withJavaScript}}var AutoSelectTextareaComponent = AutoSelectInputComponent.extendComponent({
  template: function () {
    return 'AutoSelectTextareaComponent';
  },

  events: function () {
    return AutoSelectTextareaComponent.__super__.events.call(this).concat({
      'change textarea': this.onChange,
      'click textarea': this.onClick
    });
  }
}).register('AutoSelectTextareaComponent');{{/withJavaScript}}

{{#withES2015}}class AutoSelectTextareaComponent extends AutoSelectInputComponent {
  template() {
    return 'AutoSelectTextareaComponent';
  }

  events() {
    return super.events().concat({
      'change textarea': this.onChange,
      'click textarea': this.onClick
    });
  }
}

AutoSelectTextareaComponent.register('AutoSelectTextareaComponent');{{/withES2015}}

  </div>
</div>

<p>Now we only need to inherit from the parent template, override which template to use and hook the event handlers for
textarea as well.</p>
<p>This could be made even simpler if our original component already hooked the events in a generic way, like</p>

{{#withCoffeeScript}}events: -&gt; [
  'change *': @onChange
  'click *': @onClick
]{{/withCoffeeScript}}

{{#withJavaScript}}events: function () {
  return [{
    'change *': this.onChange,
    'click *': this.onClick
  }]
},{{/withJavaScript}}

{{#withES2015}}events() {
  return [{
    'change *': this.onChange,
    'click *': this.onClick
  }];
}{{/withES2015}}

<a name="real-time-input"></a>
<h3>Real-time Input</h3>

<p>An input form element triggers the change event once we press enter or click outside it. Since Meteor's
  great strength is its reactivity, it would be nice if inputs updated in real-time as we type.</p>
<p>We'll call this extension real-time input. All we need to do is add in the code that calls the change event on
  each keypress.</p>

<div class="demo">
  <div class="live">
    {{> RealTimeInputComponent id='demo4'}}
    {{> autoSelectDemo id='demo4'}}
  </div>

  <div class="code">
    <div class="header">spacebars</div>

{{#withSpacebars}}{{|&gt; RealTimeInputComponent id='demo4'}}{{/withSpacebars}}

{{> languageSwitch}}

{{#withCoffeeScript}}class RealTimeInputComponent extends AutoSelectInputComponent
  @register 'RealTimeInputComponent'

  events: -&gt;
    super.concat
      'keyup input': @onKeyup

  onKeyup: (event) -&gt;
    $(event.target).change(){{/withCoffeeScript}}

{{#withJavaScript}}var RealTimeInputComponent = AutoSelectInputComponent.extendComponent({
  events: function () {
    return RealTimeInputComponent.__super__.events.call(this).concat({
      'keyup input': this.onKeyup
    });
  },

  onKeyup: function (event) {
    $(event.target).change();
  }
}).register('RealTimeInputComponent');{{/withJavaScript}}

{{#withES2015}}class RealTimeInputComponent extends AutoSelectInputComponent {
  events() {
    return super.events().concat({
      'keyup input': this.onKeyup
    });
  }

  onKeyup(event) {
    $(event.target).change();
  }
}

RealTimeInputComponent.register('RealTimeInputComponent');{{/withES2015}}

  </div>
</div>

<a name="persistent-input"></a>
<h3>Persistent Input</h3>

<p>You might have experienced so far that the input randomly updated while you were typing. This is because the value
in the input boxes come from a single database. If any other user has changed the text in the input, the value is
  reactively propagated to everywhere else in the world where this page is opened!</p>
  <p>Try opening another browser side by side and observe as the values change in both windows. In the example below,
we are simulating a change every 3 seconds for convenience.</p>
<p>In such collaborative environments, we need to make sure that the value in the input box doesn't change while you're
editing it. To enable this, we'll store the current value (using
  <a href="https://github.com/peerlibrary/meteor-reactive-field">reactive-field</a> package) when the input box gets
  focus and keep returning it to the rendering engine while we're editing, even if the reactive change would demand
  otherwise. This will trick the rendering engine to think that nothing has changed and will not cause re-rendering.</p>

<div class="demo">
  <div class="live">
    {{> PersistentInputComponent id='demo5'}}
    {{> autoSelectDemo id='demo5'}}
  </div>

  <div class="code">
    <div class="header">spacebars</div>

{{#withSpacebars}}{{|&gt; PersistentInputComponent id='demo5'}}{{/withSpacebars}}

{{> languageSwitch}}

{{#withCoffeeScript}}class PersistentInputComponent extends AutoSelectInputComponent
  @register 'PersistentInputComponent'

  onCreated: -&gt;
    # This will store the value at the start of editing.
    @storedValue = new ReactiveField()

  value: -&gt;
    # Return stored value during editing or normal otherwise.
    @storedValue() or super

  events: -&gt;
    super.concat
      'focus input': @onFocus
      'blur input': @onBlur

  onFocus: (event) -&gt;
    # Store the current value when starting to edit.
    @storedValue @value()

  onBlur: (event) -&gt;
    # We are no longer editing, so return to normal.
    @storedValue null{{/withCoffeeScript}}

{{#withJavaScript}}var PersistentInputComponent = AutoSelectInputComponent.extendComponent({
  onCreated: function () {
    // This will store the value at the start of editing.
    this.storedValue = new ReactiveField();
  },

  value: function () {
    // Return stored value during editing or normal otherwise.
    return this.storedValue() || PersistentInputComponent.__super__.value.call(this);
  },

  events: function () {
    return PersistentInputComponent.__super__.events.call(this).concat({
      'focus input': this.onFocus,
      'blur input': this.onBlur
    });
  },

  onFocus: function (event) {
    // Store the current value when starting to edit.
    this.storedValue(this.value());
  },

  onBlur: function (event) {
    // We are no longer editing, so return to normal.
    this.storedValue(null);
  }
}).register('PersistentInputComponent');{{/withJavaScript}}

{{#withES2015}}class PersistentInputComponent extends AutoSelectInputComponent {
  onCreated() {
    // This will store the value at the start of editing.
    this.storedValue = new ReactiveField();
  }

  value() {
    // Return stored value during editing or normal otherwise.
    return this.storedValue() || super.value();
  }

  events() {
    return super.events().concat({
      'focus input': this.onFocus,
      'blur input': this.onBlur
    });
  }

  onFocus(event) {
    // Store the current value when starting to edit.
    this.storedValue(this.value());
  }

  onBlur(event) {
    // We are no longer editing, so return to normal.
    this.storedValue(null);
  }
}

PersistentInputComponent.register('PersistentInputComponent');{{/withES2015}}

  </div>
</div>

<a name="the-cooperation"></a>
<h2>The Cooperation</h2>

<p>What if we want to now have an input-box that is both real-time and persistent during editing?</p>

<figure>
  <img src="/images/Diamond-01.svg">
</figure>

<p>This cannot be expressed in a single-inheritance language such as JavaScript that uses the
  prototype chain for inheritance.</p>

<p>To address this issue Blaze Components provide mixins with <a href="http://en.wikipedia.org/wiki/Composition_over_inheritance">composition
  over inheritance</a> in mind.</p>

<p>Mixins provide small chunks of self-contained functionality. In our case we can have a mixin that just handles
  auto-selection, another one for real-time input, third for persistent state. Our
  {{#inlineCode}}SmartInputComponent{{/inlineCode}}
  would then include all three mixins.</p>

<figure>
  <img src="/images/Diamond-02.svg">
</figure>

<p>This provides for good separation of concerns. The
  {{#inlineCode}}SmartInputComponent{{/inlineCode}}
  will implement the specific logic of reading and writing the value to the database, while delegating to mixins to
  handle their own minimal implementation of the single things they're supposed to do.</p>

<div class="demo">
  <div class="live">
    {{> SmartInputComponent id='demo6'}}
    {{> autoSelectDemo id='demo6'}}
  </div>

  <div class="code">
    <div class="header">spacebars</div>

{{#withSpacebars}}{{|&gt; SmartInputComponent id='demo6'}}{{/withSpacebars}}

{{> languageSwitch}}

{{#withCoffeeScript}}class SmartInputComponent extends BlazeComponent
  @register 'SmartInputComponent'

  template: -&gt;
    'input'

  mixins: -&gt;
    [AutoSelectInputMixin, RealTimeInputMixin, PersistentInputMixin]

  value: -&gt;
    @callFirstWith(@, 'value') or Values.findOne(@data().id)?.value

  events: -&gt; [
    'change input': @onChange
  ]

  onChange: (event) -&gt;
    Values.upsert @data().id, $set: value: event.target.value{{/withCoffeeScript}}

{{#withJavaScript}}var SmartInputComponent = BlazeComponent.extendComponent({
  template: function () {
    return 'input';
  },

  mixins: function () {
    return [AutoSelectInputMixin, RealTimeInputMixin, PersistentInputMixin];
  },

  value: function () {
    var value = this.callFirstWith(this, 'value');
    if (value) return value;
    var doc = Values.findOne(this.data().id);
    if (doc) return doc.value;
  },

  events: function () {
    return [{
      'change input': this.onChange
    }];
  },

  onChange: function (event) {
    Values.upsert(this.data().id, {$set: {
      value: event.target.value
    }});
  }
}).register('SmartInputComponent');{{/withJavaScript}}

{{#withES2015}}class SmartInputComponent extends BlazeComponent {
  template() {
    return 'input';
  }

  mixins() {
    return [AutoSelectInputMixin, RealTimeInputMixin, PersistentInputMixin];
  }

  value() {
    var value = this.callFirstWith(this, 'value');
    if (value) return value;
    var doc = Values.findOne(this.data().id);
    if (doc) return doc.value;
  }

  events() {
    return [{
      'change input': this.onChange
    }];
  }

  onChange(event) {
    Values.upsert(this.data().id, {$set: {
      value: event.target.value
    }});
  }
}

SmartInputComponent.register('SmartInputComponent');{{/withES2015}}

  </div>
</div>

<p>The code for the {{#inlineCode}}SmartInputComponent{{/inlineCode}}
  above is very similar to what we did so far, with two differences.</p>
<p>We use the
  <a href="https://github.com/peerlibrary/meteor-blaze-components#user-content-reference_instance_mixins">{{#inlineCode}}mixins{{/inlineCode}}</a>
  method to return the list of mixin classes that we want to include in our component.</p>

<aside>
  <p>Each mixin becomes its own JavaScript object with its own state, but they share a life-cycle with the component.
    The component and mixins can reference each other
    <a href="https://github.com/peerlibrary/meteor-blaze-components/#mixins-1">through methods</a> provided by Blaze
    Components.</p>
</aside>

{{#withCoffeeScript}}mixins: -&gt;
  [AutoSelectInputMixin, RealTimeInputMixin, PersistentInputMixin]{{/withCoffeeScript}}

{{#withJavaScript}}mixins: function () {
  return [AutoSelectInputMixin, RealTimeInputMixin, PersistentInputMixin];
},{{/withJavaScript}}

{{#withES2015}}mixins() {
  return [AutoSelectInputMixin, RealTimeInputMixin, PersistentInputMixin];
}{{/withES2015}}

<p>We also need to modify our value helper to call mixins to get a possible value from them.</p>

<aside>
  <p><a href="https://github.com/peerlibrary/meteor-blaze-components#user-content-reference_instance_callFirstWith">{{#inlineCode}}callFirstWith{{/inlineCode}}</a>
  will find the first of the mixins that have the specified function defined and call just that one. That mixin can call
  <a href="https://github.com/peerlibrary/meteor-blaze-components#user-content-reference_instance_callFirstWith">{{#inlineCode}}callFirstWith{{/inlineCode}}</a>
  again to continue traversal of mixins.</p>
  <p>The first argument controls where the method searches for the function. We will look into that
  <a href="#callFirstWith">in more detail later</a>.</p>
</aside>

<a name="SmartInputComponent"></a>
{{#withCoffeeScript}}value: -&gt;
  @callFirstWith(@, 'value') or Values.findOne(@data().id)?.value{{/withCoffeeScript}}

{{#withJavaScript}}value: function () {
  var value = this.callFirstWith(this, 'value');
  if (value) return value;
  var doc = Values.findOne(this.data().id);
  if (doc) return doc.value;
},{{/withJavaScript}}

{{#withES2015}}value() {
  var value = this.callFirstWith(this, 'value');
  if (value) return value;
  var doc = Values.findOne(this.data().id);
  if (doc) return doc.value;
}{{/withES2015}}

<p>In inheritance we need to {{#if isCoffeeScript}}call <code class="language-coffeescript">super</code>{{/if}}{{#if isJavaScript}}use <code class="language-javascript">__super__</code>{{/if}}{{#if isES2015}}use <code class="language-javascript">super</code>{{/if}}
  to get the result of a method
  we are overriding &mdash; otherwise the child completely shadows that method. With mixins we have to perform the same
  thing to get the result from a mixin's implementation. That's what the
  <a href="https://github.com/peerlibrary/meteor-blaze-components#user-content-reference_instance_callFirstWith">{{#inlineCode}}callFirstWith{{/inlineCode}}</a>
  method does.</p>

<p>If the component defines a behavior, it is overriding behaviors from component's mixins. And mixins do the same in
  the order they are specified in the
  <a href="https://github.com/peerlibrary/meteor-blaze-components#user-content-reference_instance_mixins">{{#inlineCode}}mixins{{/inlineCode}}</a>
  method. Those earlier are overriding those later. Methods,
  <a href="https://github.com/peerlibrary/meteor-blaze-components#event-handlers">event handlers</a>, and
  <a href="https://github.com/peerlibrary/meteor-blaze-components#life-cycle-hooks-1">life-cylcle hooks</a> are all
  called in this order.
</p>

<p>Let's quickly glance over all three mixins. The code is very self explanatory.</p>

<p>{{#inlineCode}}AutoSelectInputMixin{{/inlineCode}} selects the input on click.</p>

{{#withCoffeeScript}}class AutoSelectInputMixin extends BlazeComponent
  events: -&gt; [
    'click input': @onClick
  ]

  onClick: (event) -&gt;
    $(event.target).select(){{/withCoffeeScript}}

{{#withJavaScript}}var AutoSelectInputMixin = BlazeComponent.extendComponent({
  events: function () {
    return [{
      'click input': this.onClick
    }];
  },

  onClick: function (event) {
    $(event.target).select();
  }
});{{/withJavaScript}}

{{#withES2015}}class AutoSelectInputMixin extends BlazeComponent {
  events() {
    return [{
      'click input': this.onClick
    }];
  }

  onClick(event) {
    $(event.target).select();
  }
}{{/withES2015}}

<p>{{#inlineCode}}RealTimeInputMixin{{/inlineCode}} fires change events on every keystroke.</p>

{{#withCoffeeScript}}class RealTimeInputMixin extends BlazeComponent
  events: -&gt; [
    'keyup input': @onKeyUp
  ]

  onKeyUp: (event) -&gt;
    $(event.target).change(){{/withCoffeeScript}}

{{#withJavaScript}}var RealTimeInputMixin = BlazeComponent.extendComponent({
  events: function () {
    return [{
      'keyup input': this.onKeyUp
    }];
  },

  onKeyUp: function (event) {
    $(event.target).change();
  }
});{{/withJavaScript}}

{{#withES2015}}class RealTimeInputMixin extends BlazeComponent {
  events() {
    return [{
      'keyup input': this.onKeyUp
    }];
  }

  onKeyUp(event) {
    $(event.target).change();
  }
}{{/withES2015}}

<p>And the {{#inlineCode}}PersistentInputMixin{{/inlineCode}} stores the value while editing.</p>

{{#withCoffeeScript}}class PersistentInputMixin extends BlazeComponent
  onCreated: -&gt;
    @storedValue = new ReactiveField()

  value: -&gt;
    @storedValue()

  events: -&gt; [
    'focus input': @onFocus
    'blur input': @onBlur
  ]

  onFocus: (event) -&gt;
    @storedValue @mixinParent().value()

  onBlur: (event) -&gt;
    @storedValue null{{/withCoffeeScript}}

{{#withJavaScript}}var PersistentInputMixin = BlazeComponent.extendComponent({
  onCreated: function () {
    this.storedValue = new ReactiveField();
  },

  value: function () {
    return this.storedValue();
  },

  events: function () {
    return [{
      'focus input': this.onFocus,
      'blur input': this.onBlur
    }];
  },

  onFocus: function (event) {
    this.storedValue(this.mixinParent().value());
  },

  onBlur: function (event) {
    this.storedValue(null);
  }
});{{/withJavaScript}}

{{#withES2015}}class PersistentInputMixin extends BlazeComponent {
  onCreated() {
    this.storedValue = new ReactiveField();
  }

  value() {
    return this.storedValue();
  }

  events() {
    return [{
      'focus input': this.onFocus,
      'blur input': this.onBlur
    }];
  }

  onFocus(event) {
    this.storedValue(this.mixinParent().value());
  }

  onBlur(event) {
    this.storedValue(null);
  }
}{{/withES2015}}

<p><a href="https://github.com/peerlibrary/meteor-blaze-components#user-content-reference_instance_mixinParent">{{#inlineCode}}mixinParent{{/inlineCode}}</a>
  returns the {{#inlineCode}}SmartInputComponent{{/inlineCode}} component, so mixin can access its value.
</p>

<a name="extreme-decomposition"></a>
<h2>Extreme Decomposition</h2>

<p>There is an interesting case of a recursion going on in the last example which shows that
  {{#inlineCode}}PersistentInputMixin{{/inlineCode}} and
  {{#inlineCode}}SmartInputComponent{{/inlineCode}}
  are not so independent from each other as they could be. If this is good or bad depends,
  but as an exercise let's refactor this example once more.</p>

<p>We will add one more feature: editing cancellation. When an user presses the escape key the input should be restored
  to the value before they started editing.</p>

<div class="demo">
  <div class="live">
    {{> ExtremeInputComponent id='demo7'}}
    {{> autoSelectDemo id='demo7'}}
  </div>

  <div class="code">
    <div class="header">spacebars</div>

{{#withSpacebars}}{{|&gt; ExtremeInputComponent id='demo7'}}{{/withSpacebars}}

{{> languageSwitch}}

{{#withCoffeeScript}}class ExtremeInputComponent extends BlazeComponent
  @register 'ExtremeInputComponent'

  template: -&gt;
    'input'

  mixins: -&gt; [
    AutoSelectInputMixin, RealTimeInputMixin,
    CancelableInputMixin, FormFieldMixin,
    new StorageMixin Values, 'value', =&gt; @data().id
  ]{{/withCoffeeScript}}

{{#withJavaScript}}var ExtremeInputComponent = BlazeComponent.extendComponent({
  template: function () {
    return 'input';
  },

  mixins: function () {
    return [
      AutoSelectInputMixin, RealTimeInputMixin,
      CancelableInputMixin, FormFieldMixin,
      new StorageMixin(Values, 'value', function () {
        return this.data().id;
      }.bind(this))
    ];
  }
}).register('ExtremeInputComponent');{{/withJavaScript}}

{{#withES2015}}class ExtremeInputComponent extends BlazeComponent {
  template() {
    return 'input';
  }

  mixins() {
    return [
      AutoSelectInputMixin, RealTimeInputMixin,
      CancelableInputMixin, FormFieldMixin,
      new StorageMixin(Values, 'value', () =&gt; this.data().id)
    ];
  }
}

ExtremeInputComponent.register('ExtremeInputComponent');{{/withES2015}}

  </div>
</div>

<p>{{#inlineCode}}ExtremeInputComponent{{/inlineCode}}
  is thin and all the logic is in mixins. It defines only the template and mixins.</p>

{{#withCoffeeScript}}mixins: -&gt; [
  AutoSelectInputMixin, RealTimeInputMixin,
  CancelableInputMixin, FormFieldMixin,
  new StorageMixin Values, 'value', =&gt; @data().id
]{{/withCoffeeScript}}

{{#withJavaScript}}mixins: function () {
  return [
    AutoSelectInputMixin, RealTimeInputMixin,
    CancelableInputMixin, FormFieldMixin,
    new StorageMixin(Values, 'value', function () {
      return this.data().id;
    }.bind(this))
  ];
}{{/withJavaScript}}

{{#withES2015}}mixins() {
  return [
    AutoSelectInputMixin, RealTimeInputMixin,
    CancelableInputMixin, FormFieldMixin,
    new StorageMixin(Values, 'value', () =&gt; this.data().id)
  ];
}{{/withES2015}}

<p>You can pass as a mixin an already made mixin instance. In this case we are passing a collection, a
  field name, and a selector to the {{#inlineCode}}StorageMixin{{/inlineCode}}
  to make it more reusable.</p>

<p>But let's see mixins. First {{#inlineCode}}FormFieldMixin{{/inlineCode}}.
  It just connects a form field with a getter/setter API which other mixins can provide.</p>

{{#withCoffeeScript}}class FormFieldMixin extends BlazeComponent
  value: -&gt;
    @mixinParent().callFirstWith(null, 'getValue')

  events: -&gt; [
    'change input': @onChange
  ]

  onChange: (event) -&gt;
    @mixinParent().callFirstWith(null, 'setValue', event.target.value){{/withCoffeeScript}}

{{#withJavaScript}}var FormFieldMixin = BlazeComponent.extendComponent({
  value: function () {
    return this.mixinParent().callFirstWith(null, 'getValue');
  },

  events: function () {
    return [{
      'change input': this.onChange
    }];
  },

  onChange: function (event) {
    this.mixinParent().callFirstWith(null, 'setValue', event.target.value);
  }
});{{/withJavaScript}}

{{#withES2015}}class FormFieldMixin extends BlazeComponent {
  value() {
    return this.mixinParent().callFirstWith(null, 'getValue');
  }

  events() {
    return [{
      'change input': this.onChange
    }];
  }

  onChange(event) {
    this.mixinParent().callFirstWith(null, 'setValue', event.target.value);
  }
}{{/withES2015}}

<p>We call {{#inlineCode}}getValue{{/inlineCode}}
  on the component or component's mixin, whichever
  has this method first. We do the same for {{#inlineCode}}setValue{{/inlineCode}},
  just that we also pass the argument to the method.</p>

<p>In our example, the getter/setter API is provided by the
  {{#inlineCode}}StorageMixin{{/inlineCode}}.
  It uses Meteor collections and MongoDB queries to
  read and store a value into the database. We use constructor arguments to configure its behavior.</p>

{{#withCoffeeScript}}class StorageMixin extends BlazeComponent
  constructor: (@collection, @fieldName, @selector) -&gt;

  getValue: -&gt;
    @collection.findOne(@selector())?[@fieldName]

  setValue: (value) -&gt;
    modifier = $set: {}
    modifier.$set[@fieldName] = value
    @collection.upsert @selector(), modifier{{/withCoffeeScript}}

{{#withJavaScript}}var StorageMixin = BlazeComponent.extendComponent(function (collection, fieldName, selector) {
    this.collection = collection;
    this.fieldName = fieldName;
    this.selector = selector;
  }, {
    getValue: function () {
      var doc = this.collection.findOne(this.selector());
      if (doc) return doc[this.fieldName];
    },

    setValue: function (value) {
      var modifier = {
        $set: {}
      };
      modifier.$set[this.fieldName] = value;
      this.collection.upsert(this.selector(), modifier);
    }
});{{/withJavaScript}}

{{#withES2015}}class StorageMixin extends BlazeComponent {
  constructor(collection, fieldName, selector) {
    this.collection = collection;
    this.fieldName = fieldName;
    this.selector = selector;
  }

  getValue() {
    var doc = this.collection.findOne(this.selector());
    if (doc) return doc[this.fieldName];
  }

  setValue(value) {
    var modifier = {
      $set: {}
    };
    modifier.$set[this.fieldName] = value;
    this.collection.upsert(this.selector(), modifier);
  }
}{{/withES2015}}

<p>{{#inlineCode}}CancelableInputMixin{{/inlineCode}}
  is the new mixin we are introducing. It is interesting because it is showing how a mixin can depend on another mixin.</p>

{{#withCoffeeScript}}class CancelableInputMixin extends BlazeComponent
  mixinParent: (mixinParent) -&gt;
    mixinParent.requireMixin PersistentInputMixin if mixinParent
    super

  events: -&gt; [
    'keydown input': @onKeyDown
  ]

  onKeyDown: (event) -&gt;
    # Undo renaming on escape.
    if event.keyCode is 27
      storedValue = @mixinParent().getMixin(PersistentInputMixin).storedValue()
      $(event.target).val(storedValue).change().blur(){{/withCoffeeScript}}

{{#withJavaScript}}var CancelableInputMixin = BlazeComponent.extendComponent({
  mixinParent: function (mixinParent) {
    if (mixinParent) {
      mixinParent.requireMixin(PersistentInputMixin);
    }
    return CancelableInputMixin.__super__.mixinParent.apply(this, arguments);
  },

  events: function () {
    return [{
      'keydown input': this.onKeyDown
    }];
  },

  onKeyDown: function (event) {
    // Undo renaming on escape.
    if (event.keyCode === 27) {
      var storedValue = this.mixinParent().getMixin(PersistentInputMixin).storedValue();
      $(event.target).val(storedValue).change().blur();
    }
  }
});{{/withJavaScript}}

{{#withES2015}}class CancelableInputMixin extends BlazeComponent {
  mixinParent(mixinParent) {
    if (mixinParent) {
      mixinParent.requireMixin(PersistentInputMixin2);
    }
    return super.mixinParent(mixinParent);
  }

  events() {
    return [{
      'keydown input': this.onKeyDown
    }];
  }

  onKeyDown(event) {
    // Undo renaming on escape.
    if (event.keyCode === 27) {
      var storedValue = this.mixinParent().getMixin(PersistentInputMixin2).storedValue();
      $(event.target).val(storedValue).change().blur();
    }
  }
}{{/withES2015}}

<p><a href="https://github.com/peerlibrary/meteor-blaze-components#user-content-reference_instance_callFirstWith">{{#inlineCode}}mixinParent{{/inlineCode}}</a>
  is a method which can be used as a setter or getter. When a new mixin is created for a component it is automatically
  called as a setter to store the reference back to the component. This is a great moment to require any dependencies
  the mixin might need. In our case, {{#inlineCode}}CancelableInputMixin{{/inlineCode}} is relying on the
  {{#inlineCode}}PersistentInputMixin{{/inlineCode}} to obtain the stored value.</p>

<p>In {{#inlineCode}}onKeyDown{{/inlineCode}}
  we retrieve the dependency mixin instance by querying
  with its class. This allows us then to call mixin's methods or access its properties. In our case we are
  using the {{#inlineCode}}storedValue{{/inlineCode}}
  as a public property others can access.</p>

<p>New {{#inlineCode}}PersistentInputMixin{{/inlineCode}}
  is similar to the previous implementation, but now is not tied to the component implementation anymore.</p>

{{#withCoffeeScript}}class PersistentInputMixin extends BlazeComponent
  onCreated: -&gt;
    @storedValue = new ReactiveField()

  value: -&gt;
    @storedValue() or @mixinParent().callFirstWith(@, 'value')

  events: -&gt; [
    'focus input': @onFocus
    'blur input': @onBlur
  ]

  onFocus: (event) -&gt;
    @storedValue @mixinParent().callFirstWith(null, 'value')

  onBlur: (event) -&gt;
    @storedValue null{{/withCoffeeScript}}

{{#withJavaScript}}var PersistentInputMixin = BlazeComponent.extendComponent({
  onCreated: function () {
    this.storedValue = new ReactiveField();
  },

  value: function () {
    return this.storedValue() || this.mixinParent().callFirstWith(this, 'value');
  },

  events: function () {
    return [{
      'focus input': this.onFocus,
      'blur input': this.onBlur
    }];
  },

  onFocus: function (event) {
    this.storedValue(this.mixinParent().callFirstWith(null, 'value'));
  },

  onBlur: function (event) {
    this.storedValue(null);
  }
});{{/withJavaScript}}

{{#withES2015}}class PersistentInputMixin extends BlazeComponent {
  onCreated() {
    this.storedValue = new ReactiveField();
  }

  value() {
    return this.storedValue() || this.mixinParent().callFirstWith(this, 'value');
  }

  events() {
    return [{
      'focus input': this.onFocus,
      'blur input': this.onBlur
    }];
  }

  onFocus(event) {
    this.storedValue(this.mixinParent().callFirstWith(null, 'value'));
  }

  onBlur(event) {
    this.storedValue(null);
  }
}{{/withES2015}}

<a name="callFirstWith"></a>
Let's look in more detail into two snippets.

{{#withCoffeeScript}}value: -&gt;
  @storedValue() or @mixinParent().callFirstWith(@, 'value'){{/withCoffeeScript}}

{{#withJavaScript}}value: function () {
  return this.storedValue() || this.mixinParent().callFirstWith(this, 'value');
},{{/withJavaScript}}

{{#withES2015}}value() {
  return this.storedValue() || this.mixinParent().callFirstWith(this, 'value');
}{{/withES2015}}

<p>We pass {{#inlineCoffeeScript}}@{{/inlineCoffeeScript}}{{#inlineJavaScript}}this{{/inlineJavaScript}}{{#inlineES2015}}this{{/inlineES2015}} as the first argument to the
  <a href="https://github.com/peerlibrary/meteor-blaze-components#user-content-reference_instance_callFirstWith">{{#inlineCode}}callFirstWith{{/inlineCode}}</a>
  call. This makes Blaze Components search for {{#inlineCode}}value{{/inlineCode}} method only in mixins
  after the current one. The idea here is that {{#inlineCode}}value{{/inlineCode}} was potentially called
  from the component or another mixin before the current one and now we continue and call the
  {{#inlineCode}}value{{/inlineCode}} method in the next mixin after the current one.</p>

<p>It is interesting to observe that reactivity propagates as expected. If there is a stored value we register
  a reactive dependency only on the stored value. But if a stored value is not set, we continue calling the method
  on other mixins and potentially register other reactive dependencies. In our case, a dependency from the
  {{#inlineCode}}StorageMixin{{/inlineCode}}'s
  {{#inlineCode}}getValue{{/inlineCode}}
  method.</p>

{{#withCoffeeScript}}onFocus: (event) -&gt;
  @storedValue @mixinParent().callFirstWith(null, 'value'){{/withCoffeeScript}}

{{#withJavaScript}}onFocus: function (event) {
  this.storedValue(this.mixinParent().callFirstWith(null, 'value'));
},{{/withJavaScript}}

{{#withES2015}}onFocus(event) {
  this.storedValue(this.mixinParent().callFirstWith(null, 'value'));
}{{/withES2015}}

<p>Here we pass {{#inlineCode}}null{{/inlineCode}}
  as the first argument to the
  <a href="https://github.com/peerlibrary/meteor-blaze-components#user-content-reference_instance_callFirstWith">{{#inlineCode}}callFirstWith{{/inlineCode}}</a>
  because we want to traverse the whole structure of the component and mixins, not just from the current mixin on. We are
  calling a different method than the one in which we are so we can do that, but such call might lead to an infinite
  loop if the other method would call us back. So be careful.</p>

<p>To summarize. With the first argument to
  <a href="https://github.com/peerlibrary/meteor-blaze-components#user-content-reference_instance_callFirstWith">{{#inlineCode}}callFirstWith{{/inlineCode}}</a>
  you control where the method searches for the property. If you pass {{#inlineCode}}null{{/inlineCode}},
  it searchers both the component and all mixins, in order. If you pass the component (as we did in the
  <a href="#SmartInputComponent">{{#inlineCode}}SmartInputComponent{{/inlineCode}}</a> example), then it
  starts with only mixins. If you pass a mixin, then it starts with the mixin after it. The rule of thumb is that you
  can simply pass {{#inlineCoffeeScript}}@{{/inlineCoffeeScript}}{{#inlineJavaScript}}this{{/inlineJavaScript}}{{#inlineES2015}}this{{/inlineES2015}}
  to call the next available implementation of the property.</p>

<a name="more"></a>
<h2>More</h2>

<p>Blaze Components provide much more than we were able to cover in this introduction. For example,
  <a href="https://github.com/peerlibrary/meteor-blaze-components#passing-arguments">passing of arguments to components</a>,
  <a href="https://github.com/peerlibrary/meteor-blaze-components#component-based-block-helpers">component-based block helpers</a>,
  <a href="https://github.com/peerlibrary/meteor-blaze-components#animations">low-level DOM modification hooks</a>,
  <a href="https://github.com/peerlibrary/meteor-blaze-components#namespaces">namespaces</a>,
  <a href="https://github.com/peerlibrary/meteor-blaze-components#use-with-existing-classes">and use with existing classes</a>.
  Some use cases and patterns have not yet been documented, or even discovered.</p>

{{!--
TEMPLATE FOR THE DEMO

Copy/paste when adding a new section.

<div class="demo">
  <div class="live">
  </div>

  <div class="code">
    <div class="header">spacebars</div>

{{#withSpacebars}}{{/withSpacebars}}

{{> languageSwitch}}

{{#withCoffeeScript}}{{/withCoffeeScript}}

{{#withJavaScript}}{{/withJavaScript}}

{{#withES2015}}{{/withES2015}}

  </div>
</div>
--}}

{{! TODO: Things we should probably mention/show/demo are all sections from the README: passing arguments to components (better than through data context) and animations. }}

<a name="try-it-yourself"></a>
<h2>Try It Yourself</h2>

<p>You can start using Blaze Components in your Meteor package or application by adding <code>peerlibrary:blaze-components</code>
  to your list of dependencies.</p>

<p>See <a href="https://github.com/peerlibrary/meteor-blaze-components">Blaze Components GitHub repository</a> for a more detailed
  documentation and API reference.</p>

<p>Blaze Components are an open source project and licensed under the permissive BSD license.</p>

</body>

<template name="autoSelectDemo">
  {{#if value}}
    <p>The stored value is {{value}}.</p>
  {{else}}
    <p>Please type in something.</p>
  {{/if}}
</template>

<template name="input">
  <input value="{{value}}"/>
</template>

<template name="AutoSelectTextareaComponent">
  <textarea>{{value}}</textarea>
</template>

<template name="languageSwitch">
  <div class="header">{{#if isES2015}}es2015&nbsp;&nbsp;&nbsp;<a href="">javascript</a>&nbsp;&nbsp;&nbsp;<a href="">coffeescript</a>{{/if}}{{#if isCoffeeScript}}<a href="">es2015</a>&nbsp;&nbsp;&nbsp;<a href="">javascript</a>&nbsp;&nbsp;&nbsp;coffeescript{{/if}}{{#if isJavaScript}}<a href="">es2015</a>&nbsp;&nbsp;&nbsp;javascript&nbsp;&nbsp;&nbsp;<a href="">coffeescript</a>{{/if}}</div>
</template>

<template name="languageChooser">
  <select id="languageChooser">
    <option value="es2015" selected={{isES2015}}>ES2015</option>
    <option value="javascript" selected={{isJavaScript}}>vanilla JavaScript</option>
    <option value="coffeescript" selected={{isCoffeeScript}}>CoffeeScript</option>
  </select>
</template>

<template name="withSpacebars">
<pre><code class="language-handlebars">{{> Template.contentBlock}}</code></pre>
</template>

<template name="withCoffeeScript">
{{#if isCoffeeScript}}<pre><code class="language-coffeescript">{{> Template.contentBlock}}</code></pre>{{/if}}
</template>

<template name="withJavaScript">
{{#if isJavaScript}}<pre><code class="language-javascript">{{> Template.contentBlock}}</code></pre>{{/if}}
</template>

<template name="withES2015">
{{#if isES2015}}<pre><code class="language-javascript">{{> Template.contentBlock}}</code></pre>{{/if}}
</template>

<template name="inlineSpacebars">
<code class="language-handlebars">{{> Template.contentBlock}}</code>
</template>

<template name="inlineCoffeeScript">
{{#if isCoffeeScript}}<code class="language-coffeescript">{{> Template.contentBlock}}</code>{{/if}}
</template>

<template name="inlineJavaScript">
{{#if isJavaScript}}<code class="language-javascript">{{> Template.contentBlock}}</code>{{/if}}
</template>

<template name="inlineES2015">
{{#if isES2015}}<code class="language-javascript">{{> Template.contentBlock}}</code>{{/if}}
</template>

<template name="inlineCode">
{{#if isCoffeeScript}}<code class="language-coffeescript">{{> Template.contentBlock}}</code>{{/if}}{{#if isJavaScript}}<code class="language-javascript">{{> Template.contentBlock}}</code>{{/if}}{{#if isES2015}}<code class="language-javascript">{{> Template.contentBlock}}</code>{{/if}}
</template>
